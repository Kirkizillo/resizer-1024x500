<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Resizer 1024√ó500 (fondo + logo)</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#0f1720; --edge:#334155; --text:#e5eef7; --muted:#93a4b8; --guide:#ff4d4d; --safe:#ffd166; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
    header{padding:12px 16px;border-bottom:1px solid #1f2937;background:linear-gradient(180deg,#0f1720,#0b0f14)}
    h1{margin:0;font-size:16px;font-weight:600}
    main{display:grid;place-items:center;gap:16px;padding:20px}
    .frame{display:inline-block;padding:18px;border-radius:12px;background:var(--panel);box-shadow:0 12px 30px #00000055;max-width:98vw}
    .canvas-wrap{position:relative;display:inline-block}
    canvas{display:block;width:1024px;height:500px;background-image:
      linear-gradient(45deg,#1b2430 25%,transparent 25%),
      linear-gradient(-45deg,#1b2430 25%,transparent 25%),
      linear-gradient(45deg,transparent 75%,#1b2430 75%),
      linear-gradient(-45deg,transparent 75%,#1b2430 75%);
      background-size:22px 22px; background-position:0 0,0 11px,11px -11px,-11px 0;
      outline:2px solid var(--edge); outline-offset:8px; border-radius:6px; cursor:grab;
    }
    canvas:active{cursor:grabbing}
    .toolbar{display:flex;gap:10px;align-items:center;justify-content:center;margin:12px 0;flex-wrap:wrap}
    label.file{display:inline-flex;gap:.5rem;align-items:center;border:1px dashed #3a4b61;padding:.55rem .8rem;border-radius:.6rem;cursor:pointer;color:var(--muted)}
    input[type="file"]{display:none}
    button, select, input[type="number"], input[type="range"], input[type="color"], input[type="text"]{appearance:none;border:1px solid #253445;background:#0e1520;color:var(--text);padding:.55rem .8rem;border-radius:.6rem;cursor:pointer}
    button:hover, select:hover, input[type="number"]:hover, input[type="color"]:hover, input[type="text"]:hover{border-color:#35506d;box-shadow:0 0 0 3px #1e293b66}
    input[type="color"]{width:44px;height:34px;padding:0}
    .muted{color:var(--muted);font-size:12px;margin-top:8px;text-align:center}
    .toggle{display:inline-flex;align-items:center;gap:6px;color:var(--muted);font-size:13px}
    .group{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sp{width:64px}
    .seg{display:inline-flex;border:1px solid #253445;border-radius:.6rem;overflow:hidden}
    .seg button{border:0;padding:.45rem .7rem;background:#0a1019}
    .seg button.active{background:#1d2a3b;font-weight:600}
    /* Bot√≥n de exportaci√≥n destacado */
    #downloadBtn{border:0; font-weight:700; padding:.7rem 1rem; font-size:15px;
      background:linear-gradient(135deg, #2563eb, #7c3aed);
      box-shadow:0 6px 18px #00000055; transform:translateZ(0);
    }
    #downloadBtn:hover{filter:brightness(1.06); transform:translateY(-1px)}
      /* Toast */
    .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%) translateY(20px);background:#0b1220dd;border:1px solid #2b3b55;color:#e5eef7;padding:.6rem .9rem;border-radius:.7rem;opacity:0;pointer-events:none;transition:opacity .2s, transform .2s;box-shadow:0 8px 24px #0009;font-weight:600;z-index:1000}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
  </style>
</head>
<body>
  <header><h1>Resizer 1024√ó500 ¬∑ Fondo + Logo</h1></header>
  <main>
    <div class="frame">
      <div class="toolbar group">
        <label class="file" for="bgInput">üìÅ Cargar fondo</label>
        <input id="bgInput" type="file" accept="image/*" />
        <label class="file" for="logoInput">üñºÔ∏è Cargar logo</label>
        <input id="logoInput" type="file" accept="image/*" />
        <div class="seg" role="tablist" aria-label="Capa activa">
          <button id="tabBg" class="active" title="Editar fondo">Fondo</button>
          <button id="tabLogo" title="Editar logo">Logo</button>
        </div>
        <button id="fitCover">Ajustar (cubrir)</button>
        <button id="centerBtn">Centrar</button>
        <button id="resetBtn">Reset</button>
        <button id="newBtn">Nuevo banner</button>
      </div>

      <div class="toolbar group">
        <label class="toggle"><input type="checkbox" id="toggleGuides" checked> Gu√≠as (tercios)</label>
        <label class="toggle"><input type="checkbox" id="toggleSafe" checked> √Årea texto (solo preview)</label>
      </div>

      <div class="toolbar group">
        <select id="format">
          <option value="png">PNG (sin p√©rdida)</option>
          <option value="jpeg" selected>JPEG (con p√©rdida)</option>
          <option value="webp">WEBP</option>
        </select>
        <span class="muted">Calidad</span>
        <input id="quality" type="number" class="sp" min="0.5" max="1" step="0.05" value="0.95" />
        <button id="downloadBtn">‚¨áÔ∏è Exportar 1024√ó500</button>
      </div>

      <div class="toolbar group">
        <span class="muted">Fondo abstracto</span>
        <input type="color" id="bgColor" value="#4f46e5" title="Color base" />
        <select id="bgStyle">
          <option value="soft">Degradado suave</option>
          <option value="waves">Ondas</option>
          <option value="lowpoly">Low‚Äëpoly</option>
          <option value="radial">Radial burst</option>
          <option value="stripes">Franjas diagonales</option>
        </select>
        <button id="genBgBtn">Generar fondo</button>
        <button id="varyBtn" title="Variar (semilla aleatoria)">Variar üé≤</button>
      </div>

      <div class="canvas-wrap">
        <canvas id="canvas" width="1024" height="500" title="Arrastra im√°genes o URLs aqu√≠"></canvas>
      </div>
<div class="muted" id="info" style="text-align:center">
  Capa activa: <strong id="which">Fondo</strong> ¬∑ rueda para zoom, arrastra para mover.<br>
  Atajos: <kbd>+</kbd>/<kbd>-</kbd>, flechas, <kbd>R</kbd>, <kbd>Supr</kbd><br>
  <kbd>Ctrl/Cmd + E</kbd> (exportar), <kbd>Ctrl/Cmd + Z</kbd> (deshacer), <kbd>Ctrl/Cmd + Y</kbd> o <kbd>Ctrl/Cmd + Shift + Z</kbd> (rehacer)<br>
  Tambi√©n puedes <strong>arrastrar y soltar</strong> im√°genes o <strong>URLs</strong> sobre el lienzo.
</div>
<div id="toast" class="toast" role="status" aria-live="polite"></div>
    </div>
  </main>

<script>
// === Setup b√°sico ===
const dpr = Math.max(1, window.devicePixelRatio || 1);
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
const cssW = 1024, cssH = 500;
canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
canvas.width = Math.round(cssW * dpr); canvas.height = Math.round(cssH * dpr);
ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

let bgImg = null, logoImg = null;
let bg = { x:0, y:0, scale:1 };
let logo = { x:16, y:16, scale:0.3, opacity:1 };
let active = 'bg';
let dragging = false, startX=0, startY=0, dragged=false;
let rafPending = false; // requestAnimationFrame throttle flag

// PRNG con semilla (mulberry32)
let seed = Date.now() >>> 0; let rng = mulberry32(seed);
function mulberry32(a){ return function(){ var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
function setSeed(s){ seed = (s>>>0); rng = mulberry32(seed); }
function rnd(){ return rng(); }
function rint(min,max){ return Math.floor(min + rnd()*(max-min+1)); }
function rfloat(min,max){ return min + rnd()*(min===max?0:(max-min)); }

// Historial (undo/redo)
const history = []; // stack de estados anteriores
const future = [];  // stack para rehacer
function snapshot(){
  return {
    active,
    bg: {...bg}, logo: {...logo},
    bgSrc: bgImg ? bgImg.src : null,
    logoSrc: logoImg ? logoImg.src : null,
    seed,
    gen: { color: document.getElementById('bgColor').value, style: document.getElementById('bgStyle').value }
  };
}
function pushHistory(){ history.push(snapshot()); if(history.length>50) history.shift(); future.length = 0; }
function applyState(s){
  active = s.active; setActive(active);
  bg = {...s.bg}; logo = {...s.logo};
  const tasks = [];
  if(s.bgSrc!==null){ tasks.push(loadImageFromSrc(s.bgSrc, 'bg')); } else { bgImg = null; }
  if(s.logoSrc!==null){ tasks.push(loadImageFromSrc(s.logoSrc, 'logo')); } else { logoImg = null; }
  setSeed(s.seed);
  document.getElementById('bgColor').value = s.gen.color;
  document.getElementById('bgStyle').value = s.gen.style;
  Promise.all(tasks).finally(draw);
}

// Debounce para zoom
let zoomTimer = null;

// UI refs
const el = (id)=>document.getElementById(id);
const bgInput = el('bgInput');
const logoInput = el('logoInput');
const tabBg = el('tabBg');
const tabLogo = el('tabLogo');
const which = el('which');
const toggleGuides = el('toggleGuides');
const toggleSafe = el('toggleSafe');
const formatSel = el('format');
const qualityInput = el('quality');
const downloadBtn = el('downloadBtn');
const genBgBtn = el('genBgBtn');
const varyBtn = el('varyBtn');
const newBtn = el('newBtn');
const bgColor = el('bgColor');
const bgStyle = el('bgStyle');

// Validate quality input
qualityInput.addEventListener('input', ()=>{
  let val = parseFloat(qualityInput.value);
  if(isNaN(val) || val < 0.5 || val > 1){
    qualityInput.style.borderColor = '#ef4444'; // Red border for invalid
    showToast && showToast('‚ö†Ô∏è La calidad debe estar entre 0.5 y 1');
  } else {
    qualityInput.style.borderColor = ''; // Reset to default
  }
});

// Validate on blur and clamp value
qualityInput.addEventListener('blur', ()=>{
  let val = parseFloat(qualityInput.value);
  if(isNaN(val)) val = 0.95;
  val = Math.max(0.5, Math.min(1, val));
  qualityInput.value = val;
  qualityInput.style.borderColor = '';
});

function setActive(name){
  active = name; which.textContent = name === 'bg' ? 'Fondo' : 'Logo';
  tabBg.classList.toggle('active', name==='bg');
  tabLogo.classList.toggle('active', name==='logo');
}

tabBg.onclick = ()=> setActive('bg');
tabLogo.onclick = ()=> setActive('logo');

bgInput.addEventListener('change', e=>{ const f = e.target.files?.[0]; if(!f) return; loadImageFromFile(f, 'bg'); });
logoInput.addEventListener('change', e=>{ const f = e.target.files?.[0]; if(!f) return; loadImageFromFile(f, 'logo'); });

genBgBtn.addEventListener('click', ()=>{ generateAbstract(bgStyle.value, bgColor.value); pushHistory(); });
varyBtn.addEventListener('click', ()=>{ setSeed(Math.floor(Math.random()*1e9)); generateAbstract(bgStyle.value, bgColor.value); pushHistory(); });

newBtn.addEventListener('click', ()=>{
  bgImg = null; logoImg = null;
  bg = { x:0, y:0, scale:1 }; logo = { x:16, y:16, scale:0.3, opacity:1 };
  setActive('bg'); bgColor.value = '#4f46e5'; bgStyle.value = 'soft'; setSeed(Date.now());
  draw(); pushHistory();
});

function draw(){
  ctx.clearRect(0,0,cssW,cssH);

  // Draw canvas boundary frame (always visible to show uncovered areas)
  drawCanvasBoundary(ctx);

  if(bgImg){ const iw = bgImg.naturalWidth * bg.scale; const ih = bgImg.naturalHeight * bg.scale; const x = (cssW - iw)/2 + bg.x; const y = (cssH - ih)/2 + bg.y; ctx.drawImage(bgImg, x, y, iw, ih); }
  if(logoImg){ ctx.save(); ctx.globalAlpha = logo.opacity; const lw = logoImg.naturalWidth * logo.scale; const lh = logoImg.naturalHeight * logo.scale; ctx.drawImage(logoImg, logo.x, logo.y, lw, lh); ctx.restore(); }
  if(toggleGuides.checked) drawGuides(ctx);
  if(toggleSafe.checked) drawSafeArea(ctx);
}

function drawCanvasBoundary(context){
  context.save();
  // Draw a prominent border around canvas edges
  context.strokeStyle = '#3b82f6'; // Blue border
  context.lineWidth = 3;
  context.setLineDash([]);
  context.strokeRect(1.5, 1.5, cssW-3, cssH-3);

  // Draw corner markers for extra visibility
  const cornerSize = 20;
  context.strokeStyle = '#3b82f6';
  context.lineWidth = 3;
  // Top-left
  context.beginPath();
  context.moveTo(0, cornerSize); context.lineTo(0, 0); context.lineTo(cornerSize, 0);
  context.stroke();
  // Top-right
  context.beginPath();
  context.moveTo(cssW-cornerSize, 0); context.lineTo(cssW, 0); context.lineTo(cssW, cornerSize);
  context.stroke();
  // Bottom-right
  context.beginPath();
  context.moveTo(cssW, cssH-cornerSize); context.lineTo(cssW, cssH); context.lineTo(cssW-cornerSize, cssH);
  context.stroke();
  // Bottom-left
  context.beginPath();
  context.moveTo(cornerSize, cssH); context.lineTo(0, cssH); context.lineTo(0, cssH-cornerSize);
  context.stroke();

  context.restore();
}

function drawGuides(context){ context.save(); context.strokeStyle = getCss('--guide') || '#ff4d4d'; context.lineWidth = 1; context.setLineDash([6,4]); context.beginPath(); context.moveTo(cssW/3,0); context.lineTo(cssW/3,cssH); context.moveTo(2*cssW/3,0); context.lineTo(2*cssW/3,cssH); context.moveTo(0,cssH/3); context.lineTo(cssW,cssH/3); context.moveTo(0,2*cssH/3); context.lineTo(cssW,2*cssH/3); context.stroke(); context.restore(); }

function drawSafeArea(context){ const m = 16, w = 280, h = 80; context.save(); context.strokeStyle = getCss('--safe') || '#ffd166'; context.fillStyle = 'rgba(255,209,102,0.22)'; context.lineWidth = 2; context.setLineDash([10,6]); context.strokeRect(m, m, w, h); context.fillRect(m, m, w, h); context.font = '700 22px system-ui, -apple-system, Segoe UI, Roboto'; context.fillStyle = '#3a2a00'; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText('TAG', m + w/2, m + h/2); context.restore(); }

function getCss(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName); }

function fitCover(){ if(!bgImg) return; const rFrame = cssW/cssH; const rImg = bgImg.naturalWidth/bgImg.naturalHeight; bg.scale = (rImg>rFrame) ? (cssH/bgImg.naturalHeight) : (cssW/bgImg.naturalWidth); bg.x=0; bg.y=0; draw(); pushHistory(); }
function center(){ if(active==='bg'){ bg.x=0; bg.y=0; } else if(logoImg){ logo.x=(cssW - logoImg.naturalWidth*logo.scale)/2; logo.y=(cssH - logoImg.naturalHeight*logo.scale)/2; } draw(); pushHistory(); }
function reset(){ if(active==='bg'){ bg.scale=1; bg.x=0; bg.y=0; } else if(logoImg){ const targetH = cssH * 0.2; logo.scale = targetH / logoImg.naturalHeight; logo.x = 16; logo.y = 16; } draw(); pushHistory(); }

function zoomAt(clientX, clientY, factor){ const rect = canvas.getBoundingClientRect(); const cx = (clientX - rect.left) / rect.width * cssW; const cy = (clientY - rect.top) / rect.height * cssH; if(active==='bg'){ const prev = bg.scale; bg.scale *= factor; bg.x = cx - (cx - bg.x)*(bg.scale/prev); bg.y = cy - (cy - bg.y)*(bg.scale/prev); } else if(active==='logo' && logoImg){ const lw = logoImg.naturalWidth*logo.scale; const lh = logoImg.naturalHeight*logo.scale; const lx = logo.x + lw/2; const ly = logo.y + lh/2; const prev = logo.scale; logo.scale *= factor; const lw2 = logoImg.naturalWidth*logo.scale; const lh2 = logoImg.naturalHeight*logo.scale; logo.x = lx - lw2/2; logo.y = ly - lh2/2; } draw(); clearTimeout(zoomTimer); zoomTimer = setTimeout(()=>pushHistory(), 250); }

// === Reescalado progresivo (para nitidez) ===
function progressiveScale(imgEl, targetW, targetH){ let ow = imgEl.naturalWidth, oh = imgEl.naturalHeight; let oc = document.createElement('canvas'); oc.width = ow; oc.height = oh; let octx = oc.getContext('2d'); octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high'; octx.drawImage(imgEl,0,0); while (oc.width*0.5 > targetW || oc.height*0.5 > targetH){ const oc2 = document.createElement('canvas'); oc2.width = Math.max(targetW, Math.floor(oc.width*0.5)); oc2.height = Math.max(targetH, Math.floor(oc.height*0.5)); const o2 = oc2.getContext('2d'); o2.imageSmoothingEnabled = true; o2.imageSmoothingQuality='high'; o2.drawImage(oc, 0, 0, oc.width, oc.height, 0, 0, oc2.width, oc2.height); oc = oc2; } return oc; }

function exportImage(){ const out = document.createElement('canvas'); out.width = cssW; out.height = cssH; const octx = out.getContext('2d'); octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high'; if(bgImg){ const iw = bgImg.naturalWidth*bg.scale, ih = bgImg.naturalHeight*bg.scale; const x=(cssW-iw)/2+bg.x, y=(cssH-ih)/2+bg.y; const sourceBg = progressiveScale(bgImg, Math.min(iw, cssW*2), Math.min(ih, cssH*2)); octx.drawImage(sourceBg, x, y, iw, ih); } if(logoImg){ octx.save(); octx.globalAlpha = logo.opacity; const lw = logoImg.naturalWidth*logo.scale, lh = logoImg.naturalHeight*logo.scale; const sourceLogo = progressiveScale(logoImg, Math.min(lw, cssW), Math.min(lh, cssH)); octx.drawImage(sourceLogo, logo.x, logo.y, lw, lh); octx.restore(); } const fmt = formatSel.value; const mime = fmt==='png'?'image/png':(fmt==='jpeg'?'image/jpeg':'image/webp'); const q = Math.max(0.5, Math.min(1, parseFloat(qualityInput.value||'0.95'))); out.toBlob(b=>{ if(!b){ alert('No se pudo exportar. Si usaste una imagen por URL, puede que no permita exportar por CORS. Prueba a descargarla y cargarla como archivo.'); return; } const url = URL.createObjectURL(b); const a=document.createElement('a'); const ext = fmt==='jpeg'?'jpg':fmt; a.href=url; a.download=`export_1024x500.${ext}`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }, mime, fmt==='png'?1:q); }

// === FONDOS ABSTRACTOS (5 estilos + semilla) ===
function generateAbstract(style, hex){ const c = document.createElement('canvas'); c.width = cssW; c.height = cssH; const g = c.getContext('2d'); g.imageSmoothingEnabled = true; g.imageSmoothingQuality = 'high'; const base = hexToRgb(hex); const light = adjust(base, 0.18); const dark = adjust(base, -0.22);
  if(style === 'soft'){ const lg = g.createLinearGradient(0,0, cssW, cssH); lg.addColorStop(0, rgbStr(light)); lg.addColorStop(1, rgbStr(dark)); g.fillStyle = lg; g.fillRect(0,0,cssW,cssH); const rg = g.createRadialGradient(cssW*rfloat(0.6,0.8), cssH*rfloat(0.2,0.4), 50, cssW*0.7, cssH*0.3, Math.max(cssW,cssH)); rg.addColorStop(0, 'rgba(255,255,255,0.15)'); rg.addColorStop(1, 'rgba(255,255,255,0)'); g.fillStyle = rg; g.fillRect(0,0,cssW,cssH); }
  else if(style === 'waves'){ const lg = g.createLinearGradient(0,0, 0, cssH); lg.addColorStop(0, rgbStr(light)); lg.addColorStop(1, rgbStr(dark)); g.fillStyle = lg; g.fillRect(0,0,cssW,cssH); const layers = rint(3,5); for(let i=0;i<layers;i++){ g.save(); g.globalAlpha = 0.15 + i*0.07; g.fillStyle = i%2? rgbStr(adjust(base, 0.1-i*0.04)) : 'rgba(255,255,255,0.12)'; g.beginPath(); const amp = rfloat(14,28) + i*8; const step = 28; const y0 = cssH*(0.30 + i*0.14); g.moveTo(0, y0); const freq = rfloat(0.008,0.015); const phase = rfloat(0, Math.PI*2); for(let x=0;x<=cssW;x+=step){ const y = y0 + Math.sin(x*freq + phase)*amp; g.lineTo(x, y); } g.lineTo(cssW, cssH); g.lineTo(0, cssH); g.closePath(); g.fill(); g.restore(); } }
  else if(style === 'lowpoly'){ const lg = g.createLinearGradient(0,0, cssW, cssH); lg.addColorStop(0, rgbStr(light)); lg.addColorStop(1, rgbStr(dark)); g.fillStyle = lg; g.fillRect(0,0,cssW,cssH); const cols = 12, rows = 6; const jx = 10, jy = 8; const alpha = 0.85; const delta = 0.12; const pts = []; for(let y=0;y<=rows;y++){ const row=[]; for(let x=0;x<=cols;x++){ const px = (x/cols)*cssW + rfloat(-jx, jx); const py = (y/rows)*cssH + rfloat(-jy, jy); row.push({x:px, y:py}); } pts.push(row); } for(let y=0;y<rows;y++){ for(let x=0;x<cols;x++){ const p00=pts[y][x], p10=pts[y][x+1], p01=pts[y+1][x], p11=pts[y+1][x+1]; g.save(); g.globalAlpha = alpha; g.beginPath(); g.moveTo(p00.x,p00.y); g.lineTo(p10.x,p10.y); g.lineTo(p11.x,p11.y); g.closePath(); let c1 = adjust(base, rfloat(-delta, delta)); g.fillStyle = `rgb(${c1.r},${c1.g},${c1.b})`; g.fill(); g.beginPath(); g.moveTo(p00.x,p00.y); g.lineTo(p11.x,p11.y); g.lineTo(p01.x,p01.y); g.closePath(); let c2 = adjust(base, rfloat(-delta, delta)); g.fillStyle = `rgb(${c2.r},${c2.g},${c2.b})`; g.fill(); g.restore(); } } const vg = g.createRadialGradient(cssW/2, cssH/2, cssH*0.2, cssW/2, cssH/2, cssW*0.8); vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.18)'); g.fillStyle=vg; g.fillRect(0,0,cssW,cssH); }
  else if(style === 'radial'){ const lg = g.createLinearGradient(0,0, cssW, cssH); lg.addColorStop(0, rgbStr(adjust(base, 0.12))); lg.addColorStop(1, rgbStr(adjust(base, -0.18))); g.fillStyle = lg; g.fillRect(0,0,cssW,cssH); const rays = rint(28, 56); const cx = cssW/2, cy = cssH/2; for(let i=0;i<rays;i++){ const a0 = rfloat(0, Math.PI*2); const w = rfloat(0.02, 0.09); const a1 = a0 + w; g.save(); g.beginPath(); g.moveTo(cx, cy); g.arc(cx, cy, Math.max(cssW,cssH), a0, a1); g.closePath(); g.fillStyle = `rgba(${base.r},${base.g},${base.b},${rfloat(0.04,0.12)})`; g.fill(); g.restore(); } }
  else if(style === 'stripes'){ const lg = g.createLinearGradient(0,0, cssW, cssH); lg.addColorStop(0, rgbStr(light)); lg.addColorStop(1, rgbStr(dark)); g.fillStyle = lg; g.fillRect(0,0,cssW,cssH); const angle = rfloat(25*Math.PI/180, 40*Math.PI/180); g.save(); g.translate(cssW/2, cssH/2); g.rotate(angle); g.translate(-cssW/2, -cssH/2); const stripeH = rfloat(18, 44); let y = -cssH; const stripes = Math.ceil((cssH*3)/stripeH); for(let i=0;i<stripes;i++){ const adj = adjust(base, (i%2?0.12:-0.10)); g.fillStyle = `rgba(${adj.r},${adj.g},${adj.b},${rfloat(0.08,0.18)})`; g.fillRect(-cssW, y, cssW*3, stripeH); y += stripeH*1.6; } g.restore(); }
  const url = c.toDataURL('image/png'); const im = new Image(); im.onload = ()=>{ bgImg = im; bg.scale = 1; bg.x = 0; bg.y = 0; setActive('bg'); draw(); }; im.src = url; }

// Utilidades de color
function hexToRgb(hex){ const h = hex.replace('#',''); const bigint = parseInt(h.length===3 ? h.split('').map(x=>x+x).join('') : h, 16); return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 }; }
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function adjust({r,g,b}, amt){ const rn=r/255, gn=g/255, bn=b/255; const maxV=Math.max(rn,gn,bn), minV=Math.min(rn,gn,bn); let h,s; const l=(maxV+minV)/2; if(maxV===minV){ h=s=0; } else { const d=maxV-minV; s = l>0.5 ? d/(2-maxV-minV) : d/(maxV+minV); switch(maxV){ case rn: h=(gn-bn)/d + (gn<bn?6:0); break; case gn: h=(bn-rn)/d + 2; break; default: h=(rn-gn)/d + 4; } h/=6; } const newL = clamp(l + amt, 0, 1); const {r:rr,g:rg,b:rb}=hslToRgb(h,s,newL); return { r:Math.round(rr*255), g:Math.round(rg*255), b:Math.round(rb*255) }; }
function hslToRgb(h, s, l){ const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }; let r,g,b; if(s===0){ r=g=b=l; } else { const q=l<0.5 ? l*(1+s) : l + s - l*s; const p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); } return {r,g,b}; }
function rgbStr({r,g,b}){ return `rgb(${r}, ${g}, ${b})`; }
function averageColorHex(image){
  // reduce a 50x50 y calcula la media RGB
  const w = 50, h = 50;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const g = c.getContext('2d');
  g.drawImage(image, 0, 0, w, h);
  const { data } = g.getImageData(0, 0, w, h);
  let r = 0, gsum = 0, b = 0, count = 0;
  for(let i=0; i<data.length; i+=4){
    r    += data[i];
    gsum += data[i+1];
    b    += data[i+2];
    count++;
  }
  r = Math.round(r / count);
  gsum = Math.round(gsum / count);
  b = Math.round(b / count);
  return rgbToHex(r, gsum, b);
}

function rgbToHex(r,g,b){
  const toHex = v => v.toString(16).padStart(2,'0');
  return '#' + toHex(r) + toHex(g) + toHex(b);
}

// Toast
const toastEl = document.getElementById('toast');
function showToast(msg){ if(!toastEl) return; toastEl.textContent = msg; toastEl.classList.add('show'); clearTimeout(showToast._t); showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 1400); }

// === Drag & Drop (archivos e URLs directas) ===
['dragenter','dragover','dragleave','drop'].forEach(ev=>{ canvas.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }); });
canvas.addEventListener('dragover', ()=>{ canvas.style.outlineColor = '#60a5fa'; });
canvas.addEventListener('dragleave', ()=>{ canvas.style.outlineColor = getCss('--edge') || '#334155'; });
canvas.addEventListener('drop', async (e)=>{
  canvas.style.outlineColor = getCss('--edge') || '#334155';
  const dt = e.dataTransfer;
  if(dt.files && dt.files.length){ for(const f of dt.files){ if(f.type.startsWith('image/')){ loadImageFromFile(f, active); pushHistory(); return; } } }
  const url = dt.getData('text/uri-list') || dt.getData('text/plain');
  if(url){ const u = url.trim(); if(isProbablyImageURL(u)){ loadImageFromURL(u, active).then(()=>pushHistory()); } else { alert('La URL no parece ser una imagen directa. (Opcional) Podemos a√±adir un resolutor v√≠a proxy para p√°ginas normales.'); } }
});

function isProbablyImageURL(u){ return /\.(png|jpe?g|webp|gif|bmp|svg)(\?.*)?$/i.test(u); }

function loadImageFromFile(file, layer){
  // Validate file type
  if(!file.type.startsWith('image/')){
    showToast && showToast('‚ùå Error: El archivo no es una imagen v√°lida');
    return;
  }
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    if(layer==='logo'){
      logoImg = img;
      // Tama√±o original + centrado
      logo.scale = 1;
      logo.x = (cssW - img.naturalWidth) / 2;
      logo.y = (cssH - img.naturalHeight) / 2;
      setActive('logo');

      // Ajustar color base del generador al promedio del logo
      try {
        bgColor.value = averageColorHex(img);
        showToast && showToast('Color base ajustado al logo');
      } catch(_) { /* ignorar si el canvas queda tainted */ }
    } else {
      bgImg = img;
      fitCover();
      setActive('bg');
    }
    URL.revokeObjectURL(url);
    draw();
    pushHistory && pushHistory();
  };
  img.onerror = ()=>{
    URL.revokeObjectURL(url);
    showToast && showToast('‚ùå Error al cargar el archivo de imagen');
  };
  img.src = url;
}

function loadImageFromURL(url, layer){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    if(/^https?:/i.test(url)) img.crossOrigin = 'anonymous'; // para intentar evitar canvas tainted
    img.onload = ()=>{
      if(layer==='logo'){
        logoImg = img;
        // Tama√±o original + centrado
        logo.scale = 1;
        logo.x = (cssW - img.naturalWidth) / 2;
        logo.y = (cssH - img.naturalHeight) / 2;
        setActive('logo');

        // Ajustar color base del generador al promedio del logo
        try {
          bgColor.value = averageColorHex(img);
          showToast && showToast('Color base ajustado al logo');
        } catch(_) { /* ignorar si el canvas queda tainted */ }
      } else {
        bgImg = img;
        fitCover();
        setActive('bg');
      }
      draw();
      pushHistory && pushHistory();
      resolve();
    };
    img.onerror = ()=>{
      showToast && showToast('‚ùå No se pudo cargar la imagen desde la URL');
      console.error('Error de carga de imagen. Posible problema de CORS o URL inv√°lida.');
      reject();
    };
    img.src = url;
  });
}

function loadImageFromSrc(src, layer){ return new Promise((resolve)=>{ const img = new Image(); if(/^https?:/i.test(src)) img.crossOrigin = 'anonymous'; img.onload = ()=>{ if(layer==='logo'){ logoImg = img; } else { bgImg = img; } resolve(); }; img.src = src; }); }

// Eventos b√°sicos
canvas.addEventListener('mousedown', e=>{ dragging=true; dragged=false; startX=e.clientX; startY=e.clientY; });
window.addEventListener('mouseup', ()=>{ if(dragging && dragged){ pushHistory(); } dragging=false; });
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const speed = e.shiftKey?0.5:1;
  const dx=(e.clientX-startX)*speed;
  const dy=(e.clientY-startY)*speed;
  if(Math.abs(dx)>0 || Math.abs(dy)>0) dragged=true;
  startX=e.clientX; startY=e.clientY;
  if(active==='bg'){ bg.x += dx; bg.y += dy; }
  else { logo.x += dx; logo.y += dy; }
  // Throttle redraws with requestAnimationFrame
  if(!rafPending){
    rafPending = true;
    requestAnimationFrame(()=>{ draw(); rafPending = false; });
  }
});
canvas.addEventListener('wheel', e=>{ e.preventDefault(); zoomAt(e.clientX, e.clientY, e.deltaY<0?1.1:0.9); }, {passive:false});

toggleGuides.onchange = draw; toggleSafe.onchange = draw;

document.getElementById('fitCover').onclick = fitCover;
document.getElementById('centerBtn').onclick = center;
document.getElementById('resetBtn').onclick = reset;
downloadBtn.onclick = exportImage;

// Atajos de teclado: borrar, exportar, deshacer/rehacer
window.addEventListener('keydown', (e)=>{
  const key = e.key.toLowerCase();
  const inInput = ['input','textarea'].includes((document.activeElement?.tagName||'').toLowerCase());
  // Deshacer / rehacer
  if((e.ctrlKey || e.metaKey) && !inInput){
    if(key==='z' && !e.shiftKey){ // undo
      e.preventDefault();
      if(history.length){ future.push(snapshot()); const prev = history.pop(); applyState(prev); showToast('Deshecho'); }
      return;
    }
    if((key==='y') || (key==='z' && e.shiftKey)){ // redo
      e.preventDefault();
      if(future.length){ history.push(snapshot()); const next = future.pop(); applyState(next); showToast('Rehecho'); }
      return;
    }
    if(key==='e'){ e.preventDefault(); exportImage(); return; }
  }
  // Borrar imagen de la capa activa
  if((key === 'delete' || key === 'backspace') && !inInput){ e.preventDefault(); if (active === 'bg' && bgImg) { bgImg = null; draw(); pushHistory(); } else if (active === 'logo' && logoImg) { logoImg = null; draw(); pushHistory(); } }
});

// Dibujo inicial + primer snapshot
setSeed(Date.now());
draw();
pushHistory();
</script>
</body>
</html>
